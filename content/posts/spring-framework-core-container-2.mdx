---
title: "Spring Core 동작 이해하기 (2)"
description: "BeanDefinition과 Scope"
date: "2025-10-04"
tags: ["Spring"]
author: "Soddong"
draft: false
featured: true
---
### BeanDefinition
스프링 컨테이너가 Bean의 메타정보를 담아두는 추상화 모델이다.   
스프링은 다양한 형태의 빈 설정 정보(Java Config, XML, 어노테이션)를 모두 BeanDefinition이라는 하나의 모델로 추상화하여 사용한다.  
-> 즉 설정 정보에 따라 각 다른 구현체를 가진다.
![Spring Framework Core Bean Class Diagram](/images/spring-framework-core-beandefinition-class-diagram.png)

| 속성              | 설명                                                                 |
|-------------------|----------------------------------------------------------------------|
| **beanClassName** | 생성할 빈의 클래스명                                                  |
| **factoryBeanName** | 팩토리 역할을 하는 빈의 이름                                         |
| **factoryMethodName** | 빈을 생성할 팩토리 메서드명                                       |
| **scope**         | 빈의 범위 (default는 싱글톤)                                           |
| **lazyInit**      | 빈을 지연 초기화할지 여부. true일 경우, 실제 사용할 때까지 생성 지연 |
| **initMethodName** | 빈의 초기화 메서드. 빈 생성 후 의존관계 주입이 완료된 뒤 호출     |
| **destroyMethodName** | 빈의 소멸 메서드 . 빈의 생명주기가 끝나기 직전에 호출           |

#### 동작 방식
![Spring Framework Core Bean Class Diagram](/images/spring-framework-core-bean-class-diagram.png)
| No | 단계 | 설명 |
|----|------|------|
| 1  | Bean 정의 읽기, BeanDefinition 저장 | XML/어노테이션 스캔으로 메타정보를 읽어 `BeanDefinition`으로 변환.<br>ScannedGenericBeanDefinition: `@Component`, `@Service`, `@Repository`, `@Controller` 스캔 결과<br>AnnotatedGenericBeanDefinition: `@Configuration`의 `@Bean` 메서드 또는 `AnnotatedBeanDefinitionReader`로 직접 등록 |
| 2  | BeanDefinitionRegistry에 등록 | `BeanDefinitionRegistry.registerBeanDefinition(beanName, beanDefinition)` 호출로 컨텍스트 내부에 `이름 → 빈 정의` 매핑 저장 |
| 3  | 병합된 BeanDefinition 처리 | 상속(`ChildBeanDefinition`)이 있으면 부모,자식 정의를 병합해 `RootBeanDefinition` 생성, 빈 팩토리에서 사용 가능 |
| 4  | Bean 인스턴스 생성 | 병합된 `RootBeanDefinition` 기반 객체 생성.<br>`beanClassName`을 `Class`로 로딩 (`resolveBeanClass()` 등)<br>필요 시 `MethodOverride`, `LookupMethod`, `@Autowired` 등 보조 기능 처리 |
| 5  | 의존성 주입 | 생성자 주입(Constructor Injection), 프로퍼티/세터 주입(Property Injection) 수행 |
| 6  | 초기화 | 초기화 콜백, `@PostConstruct`, 초기화 메서드(`initMethodName`) 호출 |
| 7  | Bean 사용 | 애플리케이션에서 빈 인스턴스 사용 |

### Bean Scope
Spring 컨테이너에서는 빈의 스코프를 정할 수 있는데, 빈이 언제 생성되며 얼마나 유지할지 어떤범위로 공유할지를 결정한다.

* singleton   
기본 스코프로, 스프링 컨테이너 내에서 하나의 인스턴스만 존재하며 동일한 이름의 빈을 호출시 같은 인스턴스를 반환한다.

* prototype  
빈 요청시마다 매번 새로운 인스턴스를 생성하고 반환한다. 이때, 스프링은 컨테이너는 전체 lifecycle을 책임지지 않으며, 사용자가 소멸 콜백을 직접 호출해야한다.   

* 이외 web관련 scope.  
request, session, application, websocket는 web application에서만 의미있는 scope이다. 이건 추후 다루겠다!

### 구현해보자
여기서 구현한 흐름은 크게 아래 Step으로 나눴다.
- [x] Step 1: Config 기반 IoC 컨테이너 (@Configuration + @Bean)
- [x] Step 2: @Autowired 지원 (자동 의존성 주입)
- [x] Step 3: BeanDefinition 도입
- [x] Step 4: Bean 스코프 (singleton, prototype)
- [ ] Step 5: Component 스캔 (@ComponentScan)

### Step 3: BeanDefinition 도입
step2 까지 했을때, 생성과 동시에 bean 인스턴스를 등록해서 의존관계가 있을때 문제가 생겼었다.   
이걸 해결하기 위해 아래와 같은 순서로 동작하도록 했다.
* ApplicationContext 생성자 생성시, Config 내 @Bean 정보를 스캔하고 BeanDefinition만 등록
* 실제 객체는 getBean() 호출 시 생성
* 만약 의존관계가 있는 bean의 instance가 없을시 BeanDefinition을 뒤져서 생성

#### BeanDefinition 등록
1 `ApplicationContext` 생성 시 `ConfigurationProcessor`가 설정 클래스의 `@Bean` 메서드를 스캔.  
2 각 `@Bean` 메서드마다 `AnnotatedGenericBeanDefinition`을 생성 (반환 타입을 기준으로 `beanClass`에 기록).  
3 `beanDefinition`에 `@Lazy`, `@Scope` 같은 메타데이터가 있으면 설정.  
4 `DefaultBeanFactory.registerBeanDefinition(beanName, beanDefinition)`으로 등록.  

#### 조회 및 인스턴스화
1 사용자가 `getBean(beanName, beanClass)`를 호출.  
2 `DefaultBeanFactory`는 먼저 `singletonMap`에서 인스턴스를 조회.  
3 인스턴스가 없으면 `definitionMap`에서 `BeanDefinition`을 검색.  
4 `createBeanInstance(beanDefinition)`로 실제 객체를 생성.  
5 생성된 인스턴스를 `singletonMap`에 저장.  
6 `performInjection(beanInstance)`를 호출해 `@Autowired` 필드들을 채움.  

### Step 4: Bean 스코프 (singleton, prototype)
지금까지는 모든 빈이 싱글톤이라고 가정하고, 항상 singletonMap에서 꺼내오는 방식으로 동작했다.   
즉, 한 번 생성된 인스턴스를 계속 재사용하는 구조였다.   
하지만 이번에는 @Scope 어노테이션을 통해 스코프를 지정할 수 있도록 개선했다.   
동작과정은 아래와 같다.   
1 `ConfigurationProcessor`가 `@Bean` 메서드를 스캔할 때, 만약 해당 메서드에 `@Scope`가 붙어 있다면 그 값을 읽어 `BeanDefinition`의 `scope` 필드에 set한다.     
2 이후 `getBean()` 호출 시, 등록된 `BeanDefinition`의 스코프 정보를 확인한다.   
3-1 singleton인 경우, 기존과 동일하게 `singletonMap`에서 인스턴스를 찾아 반환한다. 없으면 새로 생성해서 등록한 뒤, 그 객체를 반환한다.     
3-2 prototype인 경우, 매번 새로운 인스턴스를 생성해서 반환한다. 이때는 `singletonMap`에 저장하지 않는다.    

이렇게 하면, prototype 스코프를 가진 빈은 요청할 때마다 항상 새로 생성되며, singleton은 한 번만 만들어져 애플리케이션 전역에서 공유된다.

### 결과
```java
@Configuration
public class AppConfig {
    @Bean
    public SoddongService soddongService() {
        return new SoddongService();
    }

    @Bean
    @Scope("prototype")
    public SoddongRepository soddongRepository() {
        return new SoddongRepository();
    }
}
```
위와 같이 SoddongService는 singleton,  SoddongRepository는 prototype으로 등록   

```
public static void main(String[] args) {
    ApplicationContext applicationContext = new ApplicationContext(AppConfig.class);
    SoddongService service1 = applicationContext.getBean(SoddongService.class.getSimpleName(), SoddongService.class);
    SoddongService service2 = applicationContext.getBean(SoddongService.class.getSimpleName(), SoddongService.class);

    SoddongRepository repository1 = applicationContext.getBean(SoddongRepository.class.getSimpleName(), SoddongRepository.class);
    SoddongRepository repository2 = applicationContext.getBean(SoddongRepository.class.getSimpleName(), SoddongRepository.class);

    log.info("(scope: singleton) service 동일한 인스턴스 여부 : {}", service1 == service2);
    log.info("(scope: prototype) repository 동일한 인스턴스 여부 : {}", repository1 == repository2);
}
```
service, repository 각각 bean을 두개씩 반환하여 동일한 인스턴스인지 비교 하였다.

```bash
21:53:57.102 [main] INFO com.soddong.stdy.use.Main -- (scope: singleton) service 동일한 인스턴스 여부 : true
21:53:57.102 [main] INFO com.soddong.stdy.use.Main -- (scope: prototype) repository 동일한 인스턴스 여부 : false```
```
service는 동일한 인스턴스이고, repository는 서로다른 인스턴스임을 확인할 수 있다.