---
title: "Spring Core 동작 이해하기 (2)"
description: "스프링 프레임워크 Core(IoC/DI)를 구현해보면서 이해한 과정을 단계별로 정리한 것"
date: "2025-09-27"
tags: ["Spring"]
author: "Soddong"
draft: false
featured: true
---
### BeanDefinition
스프링 컨테이너가 Bean의 메타정보를 담아두는 추상화 모델이다.   
스프링은 다양한 형태의 빈 설정 정보(Java Config, XML, 어노테이션)를 모두 BeanDefinition이라는 하나의 모델로 추상화하여 사용한다.  
-> 즉 설정 정보에 따라 각 다른 구현체를 가진다.
![Spring Framework Core Bean Class Diagram](/images/spring-framework-core-beandefinition-class-diagram.png)

| 속성              | 설명                                                                 |
|-------------------|----------------------------------------------------------------------|
| **beanClassName** | 생성할 빈의 클래스명                                                  |
| **factoryBeanName** | 팩토리 역할을 하는 빈의 이름                                         |
| **factoryMethodName** | 빈을 생성할 팩토리 메서드명                                       |
| **scope**         | 빈의 범위 (default는 싱글톤)                                           |
| **lazyInit**      | 빈을 지연 초기화할지 여부. true일 경우, 실제 사용할 때까지 생성 지연 |
| **initMethodName** | 빈의 초기화 메서드. 빈 생성 후 의존관계 주입이 완료된 뒤 호출     |
| **destroyMethodName** | 빈의 소멸 메서드 . 빈의 생명주기가 끝나기 직전에 호출           |

#### 동작 방식
![Spring Framework Core Bean Class Diagram](/images/spring-framework-core-bean-class-diagram.png)
| No | 단계 | 설명 |
|----|------|------|
| 1  | Bean 정의 읽기, BeanDefinition 저장 | XML/어노테이션 스캔으로 메타정보를 읽어 `BeanDefinition`으로 변환.<br>ScannedGenericBeanDefinition: `@Component`, `@Service`, `@Repository`, `@Controller` 스캔 결과<br>AnnotatedGenericBeanDefinition: `@Configuration`의 `@Bean` 메서드 또는 `AnnotatedBeanDefinitionReader`로 직접 등록 |
| 2  | BeanDefinitionRegistry에 등록 | `BeanDefinitionRegistry.registerBeanDefinition(beanName, beanDefinition)` 호출로 컨텍스트 내부에 `이름 → 빈 정의` 매핑 저장 |
| 3  | 병합된 BeanDefinition 처리 | 상속(`ChildBeanDefinition`)이 있으면 부모,자식 정의를 병합해 `RootBeanDefinition` 생성, 빈 팩토리에서 사용 가능 |
| 4  | Bean 인스턴스 생성 | 병합된 `RootBeanDefinition` 기반 객체 생성.<br>`beanClassName`을 `Class`로 로딩 (`resolveBeanClass()` 등)<br>필요 시 `MethodOverride`, `LookupMethod`, `@Autowired` 등 보조 기능 처리 |
| 5  | 의존성 주입 | 생성자 주입(Constructor Injection), 프로퍼티/세터 주입(Property Injection) 수행 |
| 6  | 초기화 | 초기화 콜백, `@PostConstruct`, 초기화 메서드(`initMethodName`) 호출 |
| 7  | Bean 사용 | 애플리케이션에서 빈 인스턴스 사용 |

### 구현해보자
여기서 구현한 흐름은 크게 아래 Step으로 나눴다.
- [x] Step 1: Config 기반 IoC 컨테이너 (@Configuration + @Bean)
- [x] Step 2: @Autowired 지원 (자동 의존성 주입)
- [x] Step 3: BeanDefinition 도입
- [ ] Step 4: Bean 라이프사이클 콜백 (@PostConstruct, @PreDestroy)
- [ ] Step 5: Component 스캔 (@ComponentScan)
- [ ] Step 6: Bean 스코프 (singleton, prototype 등)

### Step 3: BeanDefinition 도입
step2 까지 했을때, 생성과 동시에 bean 인스턴스를 등록해서 의존관계가 있을때 문제가 생겼었다.   
이걸 해결하기 위해 아래와 같은 순서로 동작하도록 했다.
* ApplicationContext 생성자 생성시, Config 내 @Bean 정보를 스캔하고 BeanDefinition만 등록
* 실제 객체는 getBean() 호출 시 생성
* 만약 의존관계가 있는 bean의 instance가 없을시 BeanDefinition을 뒤져서 생성

좀 더 상세하게 설명하자면 아래와 같다.
#### BeanDefinition 등록
1. `ApplicationContext` 생성 시 `ConfigurationProcessor`가 설정 클래스의 `@Bean` 메서드를 스캔
2. 각 `@Bean` 메서드마다 `AnnotatedGenericBeanDefinition`을 생성 (반환 타입을 기준으로 `beanClass`에 기록)
3. `beanDefinition`에 `@Lazy`, `@Scope` 같은 메타데이터가 있으면 설정
4. `DefaultBeanFactory.registerBeanDefinition(beanName, beanDefinition)`으로 등록

#### 조회 및 인스턴스화
1. 사용자가 `getBean(beanName, beanClass)`를 호출
2. `DefaultBeanFactory`는 먼저 `singletonMap`에서 인스턴스를 조회
3. 인스턴스가 없으면 `definitionMap`에서 `BeanDefinition`을 검색
4. `createBeanInstance(beanDefinition)`로 실제 객체를 생성
5. 생성된 인스턴스를 `singletonMap`에 저장
6. `performInjection(beanInstance)`를 호출해 `@Autowired` 필드들을 채움